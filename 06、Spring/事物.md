## 一、背景

### 1.1 拜神

spring事务领头人叫Juergen Hoeller，于尔根·糊了...先混个脸熟哈，他写了几乎全部的spring事务代码。读源码先拜神，掌握他的源码的风格，读起来会通畅很多。最后一节咱们总结下这个大神的代码风格。

![img](https://typoralim.oss-cn-beijing.aliyuncs.com/img/20210201141233.png)



### 1.2 事务的定义

事务（Transaction）是数据库区别于文件系统的重要特性之一。目前国际认可的数据库设计原则是ACID特性，用以保证数据库事务的正确执行。Mysql的innodb引擎中的事务就完全符合ACID特性。

spring对于事务的支持，分层概览图如下：

![img](https://typoralim.oss-cn-beijing.aliyuncs.com/img/20210201140641.png)

## 二、事务的ACID特性

（箭头后，翻译自官网介绍：[InnoDB and the ACID Model ](https://dev.mysql.com/doc/refman/5.6/en/mysql-acid.html)）

- **原子性（Atomicity）：\**一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。\*\*--》\*\*\*\*主要涉及InnoDB事务。\*\*相关特性：事务的\*\*提交，回滚，信息表。\*\**\***
- **一致性（consistency）：\**\*\*数据库总是从一个一致性的状态转换到另一个一致性的状态\*\*。在事务开始前后，数据库的完整性约束没有被破坏。例如违反了唯一性，必须撤销事务，返回初始状态。\*\*\*\*--》\*\*\*\*\**\**主要\**涉及内部InnoDB处理，以保护数据不受崩溃，\**相关特性：\**双写缓冲、崩溃恢复。**
- **隔离性（isolation）：\**\*\*每个读写事务的对象对其他事务的操作对象能相互分离，即：事务\*\*提交前对其他事务是不可见的\*\*，通常内部加锁实现。\*\*\*\*--》\*\*\*\*\*\**\*主要涉及事务，尤其是事务隔离级别，相关特性：隔离级别、innodb锁的底层实现细节。**
- **持久性（durability）：\**\*\*\*\*一旦事务提交，则其所做的修改会永久保存到数据库\*\*。\*\**\**\*--》\*\*涉及到MySQL软件特性与特定硬件配置的相互影响，相关特性：4个配置项：双写缓冲开关、事务提交刷新log的级别、binlog同步频率、表文件；写缓存、操作系统对于`fsync()的支持、`备份策略等。\*\**\***

## 三、事务的属性

要保证事务的ACID特性，spring给事务定义了6个属性，对应于声明式事务注解（org.springframework.transaction.annotation.Transactional）@Transactional(key1=*,key2=*...)

- **事务名称**：用户可手动指定事务的名称，当多个事务的时候，可区分使用哪个事务。对应注解中的属性value、transactionManager
- **隔离级别**: 为了解决数据库容易出现的问题，分级加锁处理策略。 对应注解中的属性isolation
- **超时时间**: 定义一个事务执行过程多久算超时，以便超时后回滚。可以防止长期运行的事务占用资源.对应注解中的属性timeout
- **是否只读**：表示这个事务只读取数据但不更新数据, 这样可以帮助数据库引擎优化事务.对应注解中的属性readOnly
- **传播机制**: 对事务的传播特性进行定义，共有7种类型。对应注解中的属性propagation
- **回滚机制**：定义遇到异常时回滚策略。对应注解中的属性rollbackFor、noRollbackFor、rollbackForClassName、noRollbackForClassName

 其中隔离级别和传播机制比较复杂，咱们细细地品一品。



### 3.1 隔离级别

这一块比较复杂，我们从3个角度来看：3种错误现象、mysql的底层技术支持、分级处理策略。这一小节一定要好好看，已经开始涉及核心原理了。

####  **一、.现象（三种问题）**

**脏读****(Drity Read)**：事务A更新记录但未提交，事务B查询出A未提交记录。

**不可重复读****(Non-repeatable read):** 事务A读取一次，此时事务B对数据进行了更新或删除操作，事务A再次查询数据不一致。

**幻读****(Phantom Read)**: 事务A读取一次，此时事务B插入一条数据事务A再次查询，记录多了。

#### 二、 mysql的底层支持（IndoDB事务模型）（一致性非锁定读VS锁定读）

[官网飞机票：InnoDB Transaction Model](https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-model.html)

#### 两种读

在MVCC中，读操作可以分成两类，快照读（Snapshot read）和当前读（current read）。

**快照读**：普通的select

**当前读**：

1. select * from table where ? lock in share mode; （加S锁）
2. select * from table where ? for update; （加X锁）
3. insert, update, delete 操作前会先进行一次当前读（加X锁）

其中前两种锁定读,需要用户自己显式使用,最后一种是自动添加的。

#### 　　1.一致性非锁定读（快照读）

　　一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(multi versionning)的方式来读取当前执行时间数据库中行的数据，如果读取的行正在执行DELETE或UPDATE操作，这是读取操作不会因此等待行上锁的释放。相反的，InnoDB会去读取行的一个快照数据

![img](https://typoralim.oss-cn-beijing.aliyuncs.com/img/20210201140649.jpg)

 

上面展示了InnoDB存储引擎一致性的非锁定读。之所以称为非锁定读，因为不需要等待访问的行上X锁的释放。快照数据是指该行之前版本的数据，该实现是通过undo段来完成。而undo用来事务中的回滚数据，因此快照数据本身没有额外的开销，此外，读取快照数据不需要上锁，因为没有事务需要对历史数据进行修改操作。

#### 　　2.锁定读（当前读）

innoDB对select语句支持两种锁定读：

1）SELECT...FOR UPDATE:对读取的行加排它锁（X锁），其他事务不能对已锁定的行再加任何锁。



2 ) SELECT...LOCK IN SHARE MODE ：对读取的行加共享锁（S锁），其他事务可以再加S锁，X锁会阻塞等待。

注：这两种锁都必须处于事务中，事务commit，锁释放。所以必须begin或者start transaction 开启一个事务或者索性set autocommit=0把自动提交关掉（mysql默认是1，即执行完sql立即提交）

#### **三、.分级处理策略（四种隔离级别）**

**官网描述：**

InnoDB使用不同的锁定策略支持每个事务隔离级别。对于关键数据的操作(遵从ACID原则)，您可以使用强一致性（默认Repeatable Read）。对于不是那么重要的数据操作，可以使用Read Committed/Read Uncommitted。Serializable执行比可重读更严格的规则，用于特殊场景：XA事务，并发性和死锁问题的故障排除。

 

**四种隔离级别：**

**1.Read Uncommitted****（读取未提交内容）**：可能读取其它事务未提交的数据。-脏读问题（脏读+不可重复读+幻读）

**2.Read Committed****（读取提交内容）**：一个事务只能看见已经提交事务所做的改变。（不可重复读+幻读）

select...from : 一致性非锁定读的数据快照(MVCC)是最新版本的,但其他事务可能会有新的commit，所以同一select可能返回不同结果。-不可重复读问题
select...from for update : record lock行级锁.

**3.Repeatable Read****（可重读）**：

- select…from ：同一事务内多次一致性非锁定读，取第一次读取时建立的快照版本(MVCC)，保证了同一事务内部的可重复读.—狭义的幻读问题得到解决。（Db插入了数据，只不过读不到）
- select...from for update （FOR UPDATE or LOCK IN SHARE MODE), UPDATE, 和 DELETE : next-key lock下一键锁.

　　1）对于具有唯一搜索条件的唯一索引，innoDB只锁定找到的索引记录.   （next-key lock 降为record lock）

　　2）对于其他非索引或者非唯一索引，InnoDB会对扫描的索引范围进行锁定，使用next-key locks，阻塞其他session对间隙的insert操作，-彻底解决广义的幻读问题。（DB没插入数据）

 

**4.Serializable****（可串行化）**：这是最高的隔离级别，它是在每个读的数据行上加上共享锁（LOCK IN SHARE MODE）。在这个级别，可能导致大量的超时现象和锁竞争，主要用于分布式事务。

如下表：

| 不同隔离级别/可能出现的问题                | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------------ | ---- | ---------- | ---- |
| **Read Uncommitted****（读取未提交内容）** | ✅    | ✅          | ✅    |
| **Read Committed****（读取提交内容）**     | ❎    | ✅          | ✅    |
| **Repeatable Read****（可重读）**          | ❎    | ❎          | ✅    |
| **Serializable****（可串行化）**           | ❎    | ❎          | ❎    |



### 3.2 传播机制

org.springframework.transaction包下有一个事务定义接口TransactionDefinition，定义了7种事务传播机制，很多人对传播机制的曲解从概念开始，所以特地翻译了一下源码注释如下：

#### 1.PROPAGATION_REQUIRED

支持当前事务;如果不存在，创建一个新的。类似于同名的EJB事务属性。这通常是事务定义的默认设置，通常定义事务同步作用域。

#### 2.PROPAGATION_SUPPORTS

支持当前事务;如果不存在事务，则以非事务方式执行。类似于同名的EJB事务属性。
注意:
对于具有事务同步的事务管理器，PROPAGATION_SUPPORTS与没有事务稍有不同，因为它可能在事务范围内定义了同步。因此，相同的资源(JDBC的Connection、Hibernate的Session等)将在整个指定范围内共享。注意，确切的行为取决于事务管理器的实际同步配置!
小心使用PROPAGATION_SUPPORTS!特别是，不要依赖PROPAGATION_REQUIRED或PROPAGATION_REQUIRES_NEW,在PROPAGATION_SUPPORTS范围内(这可能导致运行时的同步冲突)。如果这种嵌套不可避免，请确保适当地配置事务管理器(通常切换到“实际事务上的同步”)。

#### 3.PROPAGATION_MANDATORY

支持当前事务;如果当前事务不存在，抛出异常。类似于同名的EJB事务属性。
注意：

PROPAGATION_MANDATORY范围内的事务同步总是由周围的事务驱动。

#### 4.PROPAGATION_REQUIRES_NEW

创建一个新事务，如果存在当前事务，则挂起当前事务。类似于同名的EJB事务属性。
注意:实际事务挂起不会在所有事务管理器上开箱即用。这一点特别适用于JtaTransactionManager，它需要TransactionManager的支持。
PROPAGATION_REQUIRES_NEW范围总是定义自己的事务同步。现有同步将被挂起并适当地恢复。

#### **5.**PROPAGATION_NOT_SUPPORTED

不支持当前事务，存在事务挂起当前事务;始终以非事务方式执行。类似于同名的EJB事务属性。
注意:实际事务挂起不会在所有事务管理器上开箱即用。这一点特别适用于JtaTransactionManager，它需要TransactionManager的支持。
事务同步在PROPAGATION_NOT_SUPPORTED范围内是不可用的。现有同步将被挂起并适当地恢复。

#### **6.**PROPAGATION_NEVER

不支持当前事务;如果当前事务存在，抛出异常。类似于同名的EJB事务属性。

注意：事务同步在PROPAGATION_NEVER范围内不可用。

#### **7.**PROPAGATION_NESTED

如果当前事务存在，则在嵌套事务中执行，如果当前没有事务，类似PROPAGATION_REQUIRED（创建一个新的）。EJB中没有类似的功能。
注意：实际创建嵌套事务只对特定的事务管理器有效。开箱即用，这只适用于 DataSourceTransactionManager（JDBC 3.0驱动）。一些JTA提供者也可能支持嵌套事务。

## 四、总结

本节讲解了事务的4大特性和6大属性的概念。并简单拓展了一下概念。可能大家会比较懵逼哈，不用担心只需要心里有个概念就可以了，下一章咱们从底层源码来看事务的实现机制。下面是隔离级别的表格，

**注意：JtaTransactionManager的类注释上说：Transaction suspension (REQUIRES_NEW, NOT_SUPPORTED) is just available with a JTA TransactionManager being registered." 这是片面的，只是说JTA TransactionManager支持挂起，并没有说DataSourceTransactionManager不支持。经过第四节实测，发现完全是支持的。网上很多说REQUIRES_NEW、NOT_SUPPORTED必须要JTA TransactionManager才行的完全是错误的说法。**

| 不同传播机制  | 事务名称 | 描述                         | 事务管理器要求               | 是否支持事务 | 是否开启新事务                      | 回滚规则                                                     |
| ------------- | -------- | ---------------------------- | ---------------------------- | ------------ | ----------------------------------- | ------------------------------------------------------------ |
| REQUIRED      | 要求     | 存在加入，不存在创建新       | 无                           | ✅            | 不一定                              | 存在一个事务：1.外部有事务加入，异常回滚；2.外部没事务创建新事务，异常回滚 |
| SUPPORTS      | 支持     | 存在加入，不存在非事务       | 无                           | ✅            | ❎                                   | 最多只存在一个事务： 1.外部有事务加入，异常回滚；2.外部没事务，内部非事务，异常不回滚 |
| MANDATORY     | 强制     | 存在加入，不存在抛异常       | 无                           | ✅            | ❎                                   | 最多只存在一个事务： 1.外部存在事务加入，异常回滚；2.外部不存在事务，异常无法回滚 |
| REQUIRES_NEW  | 要求新   | 存在挂起创建新，不存在创建新 | 无                           | ✅            | ✅                                   | 可能存在1-2个事务：1.外部存在事务挂起，创建新，异常回滚自己的事务 2.外部不存在事务，创建新， 异常只回滚新事务 |
| NOT_SUPPORTED | 不支持   | 存在挂起，不存在非事务       | 无                           | ❎            | ❎                                   | 最多只存在一个事务：1. 外部有事务挂起，外部异常回滚；内部非事务，异常不回滚2.外部无事务，内部非事务，异常不回滚 |
| NEVER         | 坚决不   | 存在抛异常                   | 无                           | ❎            | ❎                                   | 最多只存在一个事务：1.外部有事务，外部异常回滚；内部非事务不回滚 2.外部非事务，内部非事务，异常不回滚 |
| NESTED        | 嵌套     | 存在嵌套，不存在创建新       | DataSourceTransactionManager | ✅            | ❎（同一个物理事务，保存点实现嵌套） | 存在一个事务：1. 外部有事务，嵌套事务创建保存点，外部异常回滚全部事务；内部嵌套事务异常回滚到保存点；2.外部不存在事务，内部创建新事务，内部异常回滚 |

 

 Java事务的类型有三种：`JDBC事务`、`JTA(Java Transaction API)事务`、`容器事务`。 常见的容器事务如Spring事务，容器事务主要是J2EE应用服务器提供的，容器事务大多是基于JTA完成，这是一个基于JNDI的，相当复杂的API实现。所以本文暂不讨论容器事务。本文主要介绍J2EE开发中两个比较基本的事务：`JDBC事务`和`JTA事务`。

## JDBC事务

JDBC的一切行为包括事务是基于一个`Connection`的，在JDBC中是通过`Connection`对象进行事务管理。在JDBC中，常用的和事务相关的方法是： `setAutoCommit`、`commit`、`rollback`等。

[![Java_jdbc](https://typoralim.oss-cn-beijing.aliyuncs.com/img/20210201141144.png)](http://47.103.216.138/wp-content/uploads/2016/08/Java_jdbc.png)

下面看一个简单的JDBC事务代码：

 

```java
public void JdbcTransfer() { 
    java.sql.Connection conn = null;
     try{ 
        conn = conn =DriverManager.getConnection("jdbc:oracle:thin:@host:1521:SID","username","userpwd"）;
         // 将自动提交设置为 false，
         //若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交
         conn.setAutoCommit(false);
         stmt = conn.createStatement(); 
         // 将 A 账户中的金额减少 500 
         stmt.execute("\
         update t_account set amount = amount - 500 where account_id = 'A'");
         // 将 B 账户中的金额增加 500 
         stmt.execute("\
         update t_account set amount = amount + 500 where account_id = 'B'");
         // 提交事务
         conn.commit();
         // 事务提交：转账的两步操作同时成功
     } catch(SQLException sqle){            
         try{ 
             // 发生异常，回滚在本事务中的操做
            conn.rollback();
             // 事务回滚：转账的两步操作完全撤销
             stmt.close(); 
             conn.close(); 
         }catch(Exception ignore){ 
         } 
         sqle.printStackTrace(); 
     } 
}
```

上面的代码实现了一个简单的转账功能，通过事务来控制转账操作，要么都提交，要么都回滚。

------

### JDBC事务的优缺点

JDBC为使用Java进行数据库的事务操作提供了最基本的支持。通过JDBC事务，我们可以将多个SQL语句放到同一个事务中，保证其ACID特性。JDBC事务的主要优点就是API比较简单，可以实现最基本的事务操作，性能也相对较好。

但是，JDBC事务有一个局限：**`一个 JDBC 事务不能跨越多个数据库！！！`**所以，如果涉及到多数据库的操作或者分布式场景，JDBC事务就无能为力了。

## JTA事务

### 为什么需要JTA

通常，JDBC事务就可以解决数据的一致性等问题，鉴于他用法相对简单，所以很多人关于Java中的事务只知道有JDBC事务，或者有人知道框架中的事务（比如Hibernate、Spring）等。但是，由于JDBC无法实现分布式事务，而如今的分布式场景越来越多，所以，JTA事务就应运而生。

如果，你在工作中没有遇到JDBC事务无法解决的场景，那么只能说你做的项目还都太小。拿电商网站来说，我们一般把一个电商网站横向拆分成商品模块、订单模块、购物车模块、消息模块、支付模块等。然后我们把不同的模块部署到不同的机器上，各个模块之间通过远程服务调用(RPC)等方式进行通信。以一个分布式的系统对外提供服务。

一个支付流程就要和多个模块进行交互，每个模块都部署在不同的机器中，并且每个模块操作的数据库都不一致，这时候就无法使用JDBC来管理事务。我们看一段代码：

 

```java
/** 支付订单处理 **/
@Transactional(rollbackFor = Exception.class)
public void completeOrder() {
    orderDao.update(); // 订单服务本地更新订单状态
    accountService.update(); // 调用资金账户服务给资金帐户加款
    pointService.update(); // 调用积分服务给积分帐户增加积分
    accountingService.insert(); // 调用会计服务向会计系统写入会计原始凭证
    merchantNotifyService.notify(); // 调用商户通知服务向商户发送支付结果通知
}
```

上面的代码是一个简单的支付流程的操作，其中调用了五个服务，这五个服务都通过RPC的方式调用，请问使用JDBC如何保证事务一致性？我在方法中增加了`@Transactional`注解，但是由于采用调用了分布式服务，该事务并不能达到ACID的效果。

JTA事务比JDBC事务更强大。一个JTA事务可以有多个参与者，而一个JDBC事务则被限定在一个单一的数据库连接。下列任一个Java平台的组件都可以参与到一个JTA事务中：`JDBC`连接、`JDO PersistenceManager` 对象、`JMS` 队列、`JMS` 主题、企业JavaBeans（`EJB`）、一个用`J2EE Connector Architecture` 规范编译的资源分配器。

------

### JTA的定义

Java事务API（`Java Transaction API`，简称JTA ） 是一个Java企业版 的应用程序接口，在Java环境中，允许完成跨越多个XA资源的分布式事务。

[![JTA](https://typoralim.oss-cn-beijing.aliyuncs.com/img/20210201141151.png)](http://47.103.216.138/wp-content/uploads/2016/08/JTA.png)

JTA和它的同胞Java事务服务(JTS；Java TransactionService)，为J2EE平台提供了分布式事务服务。不过JTA只是提供了一个接口，并没有提供具体的实现，而是由j2ee服务器提供商 根据JTS规范提供的，常见的JTA实现有以下几种：

- 1.J2EE容器所提供的JTA实现(JBoss)
- 2.独立的JTA实现:如JOTM，Atomikos.这些实现可以应用在那些不使用J2EE应用服务器的环境里用以提供分布事事务保证。如Tomcat,Jetty以及普通的java应用。

JTA里面提供了 `java.transaction.UserTransaction` ,里面定义了下面几个方法

> `begin`：开启一个事务
>
> `commit`：提交当前事务
>
> `rollback`：回滚当前事务
>
> `setRollbackOnly`：把当前事务标记为回滚
>
> `setTransactionTimeout`：设置事务的事件，超过这个事件，就抛出异常，回滚事务

这里，值得注意的是，不是使用了`UserTransaction`就能把普通的JDBC操作直接转成JTA操作，JTA对DataSource、Connection和Resource 都是有要求的，只有符合[XA规范](http://47.103.216.138/archives/681)，并且实现了XA规范的相关接口的类才能参与到JTA事务中来，关于XA规范，请看我的另外一篇文章中有相关介绍。这里，提一句，目前主流的数据库都支持XA规范。

> 要想使用用 JTA 事务，那么就需要有一个实现 `javax.sql.XADataSource` 、 `javax.sql.XAConnection` 和 `javax.sql.XAResource` 接口的 JDBC 驱动程序。一个实现了这些接口的驱动程序将可以参与 JTA 事务。一个 `XADataSource` 对象就是一个 `XAConnection` 对象的工厂。`XAConnection` 是参与 JTA 事务的 JDBC 连接。
>
> 要使用JTA事务，必须使用`XADataSource`来产生数据库连接，产生的连接为一个XA连接。
>
> XA连接（`javax.sql.XAConnection`）和非XA（`java.sql.Connection`）连接的区别在于：XA可以参与JTA的事务，而且不支持自动提交。

 

```java
public void JtaTransfer() { 
        javax.transaction.UserTransaction tx = null;
        java.sql.Connection conn = null;
         try{ 
             tx = (javax.transaction.UserTransaction) context.lookup("java:comp/UserTransaction");  //取得JTA事务，本例中是由Jboss容器管理
             javax.sql.DataSource ds = (javax.sql.DataSource) context.lookup("java:/XAOracleDS");  //取得数据库连接池，必须有支持XA的数据库、驱动程序  
             tx.begin();
            conn = ds.getConnection();
             // 将自动提交设置为 false，
             //若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交
             conn.setAutoCommit(false);
             stmt = conn.createStatement(); 
             // 将 A 账户中的金额减少 500 
             stmt.execute("\
             update t_account set amount = amount - 500 where account_id = 'A'");
             // 将 B 账户中的金额增加 500 
             stmt.execute("\
             update t_account set amount = amount + 500 where account_id = 'B'");
             // 提交事务
             tx.commit();
             // 事务提交：转账的两步操作同时成功
         } catch(SQLException sqle){            
             try{ 
                 // 发生异常，回滚在本事务中的操做
              tx.rollback();
                 // 事务回滚：转账的两步操作完全撤销
                 stmt.close(); 
                 conn.close(); 
             }catch(Exception ignore){ 
             } 
             sqle.printStackTrace(); 
         } 
     }
```

上面的例子就是一个使用JTA事务的转账操作，该操作相对依赖于J2EE容器，并且需要通过JNDI的方式获取`UserTransaction`和`Connection`。

------

### 标准的分布式事务

> 一个分布式事务（Distributed Transaction）包括一个**事务管理器**（`transaction manager`）和一个或多个**资源管理器**(`resource manager`)。一个**资源管理器**（`resource manager`）是任意类型的持久化数据存储。**事务管理器**（`transaction manager`）承担着所有事务参与单元者的相互通讯的责任。

JTA的实现方式也是基于以上这些分布式事务参与者实现的，具体的关于JTA的实现细节不是本文的重点，感兴趣的同学可以阅读[JTA 深度历险 – 原理与实现](https://www.ibm.com/developerworks/cn/java/j-lo-jta/)

- 看上面关于分布式事务的介绍是不是和2PC中的事务管理比较像？的却，2PC其实就是符合XA规范的事务管理器协调多个资源管理器的一种实现方式。 我之前有几篇文章关于2PC和3PC的，那几篇文章中介绍过分布式事务中的事务管理器是如何协调多个事务的统一提交或回滚的，后面我还会有几篇文章详细的介绍一下和分布式事务相关的内容，包括但不限于全局事务、DTP模型、柔性事务等。

------

### JTA的优缺点

JTA的优点很明显，就是提供了分布式事务的解决方案，严格的ACID。但是，标准的JTA方式的事务管理在日常开发中并不常用，因为他有很多缺点:

- 实现复杂
  - 通常情况下，JTA UserTransaction需要从JNDI获取。这意味着，如果我们使用JTA，就需要同时使用JTA和JNDI。
- JTA本身就是个笨重的API
- 通常JTA只能在应用服务器环境下使用，因此使用JTA会限制代码的复用性。

## 总结

Java事务的类型有三种：`JDBC事务`、`JTA(Java Transaction API)事务`、`容器事务`，其中JDBC的事务操作用法比较简单，适合于处理同一个数据源的操作。JTA事务相对复杂，可以用于处理跨多个数据库的事务，是分布式事务的一种解决方案。

这里还要简单说一下，虽然JTA事务是Java提供的可用于分布式事务的一套API，但是不同的J2EE平台的实现都不一样，并且都不是很方便使用，所以，一般在项目中不太使用这种较为负责的API。现在业内比较常用的分布式事务解决方案主要有异步消息确保型、TCC、最大努力通知等。关于这几种分布式事务解决方案，我会在后面的文章中介绍。欢迎关注与交流。

 分布式事务

### 什么是分布式事务

分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

### 分布式事务产生的原因

从上面本地事务来看，我们可以看为两块，一个是service产生多个节点，另一个是resource产生多个节点。

service多个节点

随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。

resource多个节点

同样的，互联网发展得太快了，我们的Mysql一般来说装千万级的数据就得进行分库分表，对于一个支付宝的转账业务来说，你给的朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。

**分布式事务的基础**

从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:

#### CAP

CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。

- C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。
- A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。
- P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。

对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。

对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。

顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。

#### BASE

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展

1. 基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。
2. 软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。
3. 最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。

BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

### 分布式事务解决方案

有了上面的理论基础后，这里介绍开始介绍几种常见的分布式事务的解决方案。

#### 是否真的要分布式事务

在说方案之前，首先你一定要明确你是否真的需要分布式事务？

上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。我见过太多团队一个人维护几个微服务，太多团队过度设计，搞得所有人疲劳不堪，而微服务过多就会引出分布式事务，这个时候我不会建议你去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。因为不论任何一种方案都会增加你系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。

如果你确定需要引入分布式事务可以看看下面几种常见的方案。

#### 2PC

说到2PC就不得不聊数据库分布式事务中的 XA Transactions。在XA协议中分为两阶段

第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.

第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

优点： 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。

缺点:

- 单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
- 同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
- 数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。

总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。

#### TCC

关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。TCC事务机制相比于上面介绍的XA，解决了其几个缺点:1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性对于TCC的解释:

- Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）
- Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
- Cancel阶段：取消执行，释放Try阶段预留的业务资源Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

举个简单的例子如果你用100元买了一瓶水，Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。

如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。

如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)

对于TCC来说适合一些:

- 强隔离性，严格一致性要求的活动业务。
- 执行时间较短的业务

实现参考:ByteTCC:https://github.com/liuyangming/ByteTCC/

#### 本地消息表

本地消息表这个方案最初是ebay提出的 ebay的完整方案https://queue.acm.org/detail.cfm?id=1394128。

此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。

对于本地消息队列来说核心是把大事务转变为小事务。还是举上面用100元去买一瓶水的例子。

1.当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。

2.这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。

3.商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。

4.针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。

本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。

#### MQ事务

在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，下面简单介绍一下MQ事务，如果想对其详细了解可以参考:https://www.jianshu.com/p/453c6e7ff81c。基本流程如下:第一阶段Prepared消息，会拿到消息的地址。

第二阶段执行本地事务。

第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。

如果确认消息失败，在RocketMq Broker中提供了定时扫描没有更新状态的消息，如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在rocketmq中是以listener的形式给发送者，用来处理。如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失

#### Saga事务

Saga是30年前一篇数据库伦理提到的一个概念。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。Saga的组成：

每个Saga由一系列sub-transaction Ti 组成每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。

Saga的执行顺序有两种：

T1, T2, T3, ..., Tn

T1, T2, ..., Tj, Cj,..., C2, C1，其中0 < j < nSaga定义了两种恢复策略：

向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。

这里要注意的是，在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。

还是拿100元买一瓶水的例子来说，这里定义

T1=扣100元 T2=给用户加一瓶水 T3=减库存一瓶水

C1=加100元 C2=给用户减一瓶水 C3=给库存加一瓶水

我们一次进行T1,T2，T3如果发生问题，就执行发生问题的C操作的反向。上面说到的隔离性的问题会出现在，如果执行到T3这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。这就是事务之间没有隔离性的问题

可以看见saga模式没有隔离性的影响还是较大，可以参照华为的解决方案:从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源。也可以在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。

具体实例:可以参考华为的servicecomb

### 最后

还是那句话，能不用分布式事务就不用，如果非得使用的话，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。上面对解决方案只是一些简单介绍，如果真正的想要落地，其实每种方案需要思考的地方都非常多，复杂度都比较大，所以最后再次提醒一定要判断好是否使用分布式事务。最后在总结一些问题,大家可以下来自己从文章找寻答案:

1. ACID和CAP的 CA是一样的吗？
2. 分布式事务常用的解决方案的优缺点是什么？适用于什么场景？
3. 分布式事务出现的原因？用来解决什么痛点？

最后这篇文章被我收录于JGrowing，一个全面，优秀，由社区一起共建的Java学习路线，如果您想参与开源项目的维护，可以一起共建，github地址为:https://github.com/javagrowing/JGrowing麻烦给个小星星哟。

 

 

 

 

 